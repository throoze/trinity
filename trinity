#!/usr/bin/env python
# ------------------------------------------------------------
# trinity
#
# Program for lexical analysis of programs in trinity language.
#
# Authors:
# Victor De Ponte, 05-38087, <rdbvictor19@gmail.com>
# Francisco Martinez, 09-10502, <frammnm@gmail.com>
#
# Usage:
#
#     $ ./trinity program.ty
#
# where program.ty is a file with theprogram to be analyzed.
# ------------------------------------------------------------
from lexer.exceptions import LexicographicalError
from lexer.lexer import Lexer
from lang import specs
import ply.yacc as yacc
import sys

SUCCESS = 0
ERR_BAD_USAGE = 1
ERR_BAD_FILENAME = 2
ERR_IO_ERROR = 3
ERR_LEXICOGRAPHICAL_ERROR = 4

usage = ' Usage:\n\n\t$ ./trinity program.ty\n\n where "program.ty" is a file with the program to be analyzed.'

if len(sys.argv) == 2:
    filename = sys.argv[1]
else:
    print usage
    exit(ERR_BAD_USAGE)

try :
    file = open(filename, 'r')
except IOError as e:
    print "trinity: IOError: %s" % str(e)
    exit(ERR_BAD_FILENAME)

try:
    inputString = file.read()
except IOError as e:
    print "trinity: IOError: %s" % str(e)
    exit(ERR_IO_ERROR)


#Gramatic Definitions
def p_trinity(p):
    'trinity:FuncDefinitions Tk_prog InstBlock Tk_end Tk_scolon'

def p_FuncDefinitions(p):
    '''FuncDefinitions:FuncDefinitions FuncDefinition
                      |lambda '''

def p_FuncDefinition(p):
    '''FuncDefinition: Tk_function Tk_ID Tk_oparen FormalParams Tk_cparen Tk_ret 
                     Type FunctionBody'''

def p_FunctionBody(p):
    'FunctionBody: Tk_beg FunInstBlock Tk_end Tk_scolon'

def p_FormalParams(p):
    '''FormalParams:FParamList
                   | lambda'''

def p_FParamList(p):
    '''FParamList: FormalParam
                 | FParamList Tk_comma FormalParam ''' 

def p_FormalParam(p):
    'FormalParam: Type Tk_ID'

def p_Type(p):
    '''Type: Tk_bool
           | Tk_number
           | Tk_mat Tk_oparen Tk_num Tk_comma Tk_num Tk_cparen
           | Tk_row Tk_oparen Tk_num Tk_cparen '''

def p_InstBlock(p):
    '''InstBlock:InstList
                | lambda '''

def p_InstList(p):
    '''InstList:Statement
               | InstList Statement '''

def p_Statement(p):
    '''Statement:Matched 
                |Unmatched '''

def p_Matched(p):
    '''Matched: Tk_if Expression Tk_then Mached Tk_else Matched Tk_end Tk_scolon
              | Print
              | Read 
              | Assigment 
              | While
              | For
              | Block ''' 

def p_Unmatched(p):
    '''Unmatched : Tk_if Expression Tk_then Statement Tk_end Tk_scolon
                 | Tk_if Expression Tk_then Matched Tk_else Unmatched Tk_end 
                   Tk_scolon'''

def p_FunInstBlock(p):
    '''FunInstBlock : FunInstList
                    | lambda '''

def p_FunInstList(p):
    '''FunInstList : FunStatement
                   | FunInstList FunStatement'''

def p_FunStatement(p):
    '''FunStatement : FunMatched
                    | FunUnmatched '''

def p_FunMatched(p):
    '''FunMatched : Tk_if Expression Tk_then FunMatched Tk_else FunMatched Tk_end                    Tk_scolon
                  | Print
                  | Read
                  | Assignment
                  | FunWhile
                  | FunFor
                  | Return
                  | FunBlock '''

def p_FunUnmatched(p):
    '''FunUnmatched : Tk_if Expression Tk_then FunStatement Tk_end Tk_scolon
                    | Tk_if Expression Tk_then FunMatched Tk_else FunUnmatched 
                      Tk_end Tk_scolon ''' 

def p_Print(p):
    '''Print : Tk_print PrintableList ''' 

def p_Printable(p):
    '''Printable : Expression
                 | Tk_str ''' 

def p_Read(p):
    '''Read : Tk_read Tk_ID Tk_scolon'''

def p_Assignment(p):
    '''Assignment : Tk_set LeftSide Expression Tk_scolon''' 

def p_LeftSide(p):
    '''LeftSide : Tk_ID
                | Tk_ID Tk_obrack Tk_num Tk_cbrack
                | Tk_ID Tk_obrack Tk_num Tk_comma Tk_num Tk_cbrack '''

def p_While(p):
    '''While : Tk_while Expression Tk_do InstBlock Tk_end Tk_scolon'''

def p_For(p):
    '''For : Tk_for Tk_ID Tk_in Expression Tk_do InstBlock Tk_end Tk_scolon '''

def p_Block(p):
    '''Block : Tk_use VariableDeclarations Tk_in InstBlock Tk_end Tk_scolon '''

def p_FunWhile(p):
    'FunWhile : Tk_while Expression Tk_do FunInstBlock Tk_end Tk_scolon '

def p_FunFor(p):
    'FunFor : Tk_for Tk_ID Tk_in Expression Tk_do FunInstBlock Tk_end Tk_scolon'

def p_Return(p):
    'Return : Tk_ret Expression Tk_scolon'

def p_FunBlock(p):
    'FunBlock : Tk_use VariableDeclarations Tk_in FunInstBlock Tk_end Tk_scolon'

def p_VariableDeclarations(p):
    '''VariableDeclarations : VariableDeclaration
                            | VariableDeclarations VariableDeclaration'''

def p_VariableDeclaration(p):
    '''VariableDeclaration : Type Tk_ID Tk_scolon
                    | Type Tk_ID Tk_assign Expression Tk_scolon ''' 

def p_Expression(p):
    '''Expression : Tk_oparen Expression Tk_cparen
                  | UnaryOperatorExpression
                  | Expression BinaryOperator Expression
                  | LeftSide
                  | FunctionCall
                  | Literal ''' 

def p_UnaryOperatorExpression(p):
    '''UnaryOperatorExpression : Tk_minus Expression %prec UMINUS
                        | Matrix Tk_trans
                        | Tk_ID Tk_trans
                        | Tk_not Expression'''

def p_Literal(p):
    '''Literal : Matrix
        | Tk_true
        | Tk_false
        | Tk_num '''

def p_Matrix(p):
    'Matrix : Tk_obrace RowList Tk_cbrace'

def p_RowList(p):
    '''RowList : Row
               | RowList Tk_colon Row '''

def p_Row(p):
    '''Row : Tk_num   
           | Row Tk_comma Tk_num ''' 

def p_FunctionCall(p):
    'FunctionCall : Tk_ID Tk_oparen Params Tk_cparen Tk_scolon' 

def p_Params(p):
    '''Params : ParamList
              | lambda''' 

def p_ParamList(p):
    '''ParamList : Expression
                 | ParamList Tk_comma Expression '''

def p_BinaryOperator(p):
    '''BinaryOperator : ArithmeticBinaryOperator
                      | BooleanBinaryOperator ''' 

def p_ArithmeticBinaryOperator(p):
    '''ArithmeticBinaryOperator : OverloadedBinaryOperator
                                | ScalarBinaryOperator
                                | CrossedBinaryOperator '''

def p_OverloadedBinaryOperator(p):
    '''OverloadedBinaryOperator : Tk_plus
                                | Tk_minus
                                | Tk_times'''

def p_ScalarBinaryOperator(p):
    '''ScalarBinaryOperator : Tk_div
                            | Tk_mod
                            | Tk_rdiv
                            | Tk_rmod'''

def p_CrossedBinaryOperator(p):
    '''CrossedBinaryOperator : Tk_mplus
                             | Tk_mminus
                             | Tk_mtimes
                             | Tk_mdiv
                             | Tk_mmod
                             | Tk_mrdiv
                             | Tk_mrmod ''' 

def p_BooleanBinaryOperator(p):
    '''BooleanBinaryOperator : Tk_eq
                             | Tk_neq
                             | Tk_leq
                             | Tk_geq
                             | Tk_great
                             | Tk_less
                             | Tk_and
                             | Tk_or ''' 





lexer = Lexer(module=specs, inputString=inputString)
#lexer = Lexer(module=specs, inputString=inputString, debug=True)
#if not lexer.lex(silent=True):
parser = yacc.yacc(module=specs)
try:
    result = parser.parse(lexer=lexer)
    print result
    exit(SUCCESS)
except LexicographicalError as e:
    print e
    exit(ERR_LEXICOGRAPHICAL_ERROR)
